"""
FastAPI Main Application for AutoFlow AI Automation Platform
Updated to work with the new PostgreSQL UUID-based database schema
and integrate the MCP_LLM_Orchestrator and AutomationEngine.
"""

from fastapi import FastAPI, Request, HTTPException, Cookie, Depends, Header
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
import os
import logging
import sys
from datetime import datetime, timedelta
import time
import uuid
import secrets
import json
from typing import Optional
from contextlib import asynccontextmanager

# Add the backend directory itself to Python path
backend_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(backend_dir)

# Import email functionality
try:
    from email_sender import send_email_directly, generate_premium_template
    EMAIL_AVAILABLE = True
    print("✅ Email functionality imported successfully")
except ImportError as e:
    EMAIL_AVAILABLE = False
    print(f"❌ Email import failed: {e}")
    # Create dummy functions
    def send_email_directly(*args, **kwargs):
        return {"success": False, "error": "Email functionality not available"}
    def generate_premium_template(*args, **kwargs):
        return ("Dummy HTML", "Dummy Text")

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


# Load environment variables from both .env and .env.local
load_dotenv()
load_dotenv('.env.local') # Load .env.local from backend directory

# --- Import our core components ---
from mcp.enhanced_custom_mcp_llm import CustomMCPLLM

# Import Custom MCP integration API
try:
    from api.custom_mcp_integration import router as custom_mcp_router
    CUSTOM_MCP_API_AVAILABLE = True
    logger.info("✅ Custom MCP API integration imported successfully")
except ImportError as e:
    CUSTOM_MCP_API_AVAILABLE = False
    logger.error(f"❌ Custom MCP API import failed: {e}")

# Import enhanced automation engine
try:
    from mcp.simple_automation_engine import get_automation_engine
    AUTOMATION_ENGINE_AVAILABLE = True
    logger.info("✅ Enhanced Automation Engine imported successfully")
except ImportError as e:
    AUTOMATION_ENGINE_AVAILABLE = False
    logger.error(f"❌ Automation Engine import failed: {e}")

# Import Production MCP Integration
try:
    from api.production_mcp_integration import router as production_mcp_router
    PRODUCTION_MCP_INTEGRATION_AVAILABLE = True
    logger.info("✅ Production MCP Integration imported successfully")
except ImportError as e:
    PRODUCTION_MCP_INTEGRATION_AVAILABLE = False
    logger.warning(f"⚠️ Production MCP Integration not available: {e}")

# from mcp.automation_engine import AutomationEngine  # Temporarily disabled due to missing drivers
from core.simple_agent_manager import AgentManager # For managing agents (creating, fetching)

# Import PostgreSQL database manager (assuming it's in db/postgresql_manager.py)
from db.postgresql_manager import (
    db_manager, init_db, close_db,
    create_user, authenticate_user, get_user_by_session, update_user_session,
    get_user_by_id,
    add_credits, deduct_credits, get_credit_history
)

# Configure detailed logging for workflow preview debugging
logging.getLogger('werkzeug').setLevel(logging.INFO)
logger.setLevel(logging.DEBUG)


# Define FastAPI lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Initialize services
    logger.info("🚀 Starting AutoFlow Platform with PostgreSQL...")
    await init_db() # Initialize the database pool from db.postgresql_manager

    # Initialize global instances of MCP_LLM_Orchestrator and AutomationEngine
    db_config = {
        "host": os.getenv("PGHOST", "localhost"),
        "port": int(os.getenv("PGPORT", 5432)),
        "user": os.getenv("PGUSER", "postgres"),
        "password": os.getenv("PGPASSWORD", "your_db_password"), # IMPORTANT: Replace with actual password or load from secure source
        "database": os.getenv("PGDATABASE", "automation")
    }

    global custom_mcp_llm, automation_engine, agent_manager_instance
    
    # Initialize Enhanced Custom MCP LLM and Automation Engine
    custom_mcp_llm = CustomMCPLLM()  # Enhanced version with individual agent storage
    automation_engine = CustomAutomationEngine(custom_mcp_llm=custom_mcp_llm)  # Enhanced automation with triggers
    
    # Initialize agent manager with the database pool
    agent_manager_instance = AgentManager(None)  # Simple version doesn't need pool

    logger.info("✅ Database connected with UUID support")
    logger.info("✅ Enhanced Custom MCP LLM and Automation Engine initialized.")
    logger.info("🔧 Features: User auth, agent management, credit system, AI automation with triggers.")

    yield  # Server runs here

    # Shutdown: Cleanup
    logger.info("🔌 Shutting down AutoFlow Platform...")
    await close_db() # Close the database pool from db.postgresql_manager


# Create FastAPI app instance
app = FastAPI(
    title="AutoFlow AI Automation Platform",
    version="3.0.0",
    lifespan=lifespan
)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Adjust for production (e.g., ["http://localhost:3000"])
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Register Production MCP Integration Router
if PRODUCTION_MCP_INTEGRATION_AVAILABLE:
    app.include_router(production_mcp_router)
    logger.info("✅ Production MCP Integration routes registered")

# Register Custom MCP API Router
if CUSTOM_MCP_API_AVAILABLE:
    app.include_router(custom_mcp_router)
    logger.info("✅ Custom MCP API routes registered")

# --- Global instances of our core components ---
# These will be initialized at startup
custom_mcp_llm: Optional[CustomMCPLLM] = None
# Use the enhanced automation engine
automation_engine = None  # Will be initialized from simple_automation_engine
agent_manager_instance: Optional[AgentManager] = None # Instance of AgentManager
custom_mcp_orchestrator = None  # Custom MCP LLM Orchestrator

# Helper function to get current user from session
async def get_current_user(
    session_token: str = Cookie(None, alias="session_token"),
    x_user_id: str = Header(None, alias="x-user-id") # For testing convenience
) -> dict: # Changed to dict, will raise HTTPException if not found
    """Extract user from session token or header, raising HTTPException if not found."""
    
    user = None
    if session_token:
        user = await get_user_by_session(session_token)
        if user:
            logger.info(f"AUTH - Found user via session: {user['email']}")
            return user
    
    if x_user_id:
        try:
            # For testing, treat x_user_id as actual user_id UUID
            user = await get_user_by_id(x_user_id)
            if user:
                logger.info(f"AUTH - Found user via header: {user['email']}")
                return user
        except Exception as e:
            logger.warning(f"AUTH - Invalid user ID in header: {e}")
    
    logger.warning("AUTH - User not authenticated or session invalid.")
    raise HTTPException(status_code=401, detail="Not authenticated")

# Helper to get or create a default "Sam" agent for a user
async def _get_or_create_default_agent(user_id: str) -> dict:
    """
    Retrieves the default 'Sam - Personal Assistant' agent for a user.
    Creates it if it doesn't exist.
    """
    # Define the default agent's characteristics
    default_agent_name = "Sam - Personal Assistant"
    default_agent_role = "General AI Assistant for Automation"
    default_agent_personality = {"tone": "friendly", "style": "helpful and concise"}
    default_agent_expectations = "Assist with general queries and initiate automation workflow creation."

    user_agents = await agent_manager_instance.get_user_agents(user_id)
    for agent in user_agents:
        if agent['agent_name'] == default_agent_name:
            logger.info(f"Found existing default agent for user {user_id}: {agent['agent_id']}")
            return agent
    
    # If not found, create it
    logger.info(f"Creating new default agent for user {user_id}: {default_agent_name}")
    new_agent = await agent_manager_instance.create_agent(
        user_id=user_id,
        agent_name=default_agent_name,
        agent_role=default_agent_role,
        agent_personality=json.dumps(default_agent_personality),
        agent_expectations=default_agent_expectations
    )
    if not new_agent:
        raise HTTPException(status_code=500, detail="Failed to create default agent.")
    return new_agent


# Lifespan context for startup/shutdown events
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Initialize services
    logger.info("🚀 Starting AutoFlow Platform with PostgreSQL...")
    await init_db() # Initialize the database pool from db.postgresql_manager

    # Initialize global instances of MCP_LLM_Orchestrator and AutomationEngine
    db_config = {
        "host": os.getenv("PGHOST", "localhost"),
        "port": int(os.getenv("PGPORT", 5432)),
        "user": os.getenv("PGUSER", "postgres"),
        "password": os.getenv("PGPASSWORD", "your_db_password"), # IMPORTANT: Replace with actual password or load from secure source
        "database": os.getenv("PGDATABASE", "automation")
    }
    fine_tuned_model_path = os.getenv("FINE_TUNED_MODEL_PATH", "finetuned-full-workflow-model")

    global custom_mcp_llm, automation_engine, agent_manager_instance, custom_mcp_orchestrator
    
    # Initialize Enhanced Custom MCP LLM and Automation Engine  
    custom_mcp_llm = CustomMCPLLM()  # Enhanced version with individual agent storage
    
    # Initialize the enhanced automation engine
    if AUTOMATION_ENGINE_AVAILABLE:
        automation_engine = get_automation_engine()
        logger.info("✅ Enhanced Automation Engine with triggers initialized")
    
    # Initialize Custom MCP Orchestrator
    try:
        from mcp.simple_mcp_llm import get_mcp_orchestrator
        custom_mcp_orchestrator = get_mcp_orchestrator()
        logger.info("✅ Custom MCP LLM Orchestrator initialized")
    except Exception as e:
        logger.error(f"❌ Failed to initialize Custom MCP Orchestrator: {e}")
        custom_mcp_orchestrator = None
    
    # Initialize agent manager with the database pool
    agent_manager_instance = AgentManager(None)  # Simple version doesn't need pool

    logger.info("✅ Database connected with UUID support")
    logger.info("✅ Enhanced Custom MCP LLM and Automation Engine initialized.")
    logger.info("🔧 Features: User auth, agent management, credit system, AI automation with triggers.")

    yield  # Server runs here

    # Shutdown: Cleanup
    logger.info("🔌 Shutting down AutoFlow Platform...")
    await close_db() # Close the database pool from db.postgresql_manager
    # Close any other pools if they were created separately (e.g., in drivers)
    
    # Stop automation engine trigger monitoring
    if automation_engine:
        automation_engine.stop_trigger_monitoring()
        
    logger.info("✅ Database connections closed")
    logger.info("👋 AutoFlow AI Platform shut down gracefully")

# Add middleware to log all requests
@app.middleware("http")
async def log_requests(request: Request, call_next):
    logger.info(f"🌐 REQUEST: {request.method} {request.url}")
    response = await call_next(request)
    return response

# Core Health Check
@app.get("/health")
async def health():
    return {
        "status": "ok", 
        "message": "AutoFlow Platform is running",
        "database": "PostgreSQL with UUIDs",
        "timestamp": datetime.utcnow().isoformat()
    }

# ===== AUTHENTICATION ENDPOINTS =====

@app.post("/api/auth/signup")
async def signup(request: Request):
    """User registration endpoint."""
    try:
        body = await request.json()
        email = body.get('email')
        password = body.get('password')
        first_name = body.get('firstName', '')
        last_name = body.get('lastName', '')
        username = body.get('username')
        organization = body.get('organization', False)
        
        if not email or not password:
            return JSONResponse(
                status_code=400,
                content={"error": "Email and password are required"}
            )
        
        user = await create_user(
            email=email,
            password=password,
            first_name=first_name,
            last_name=last_name,
            username=username,
            organization=organization
        )
        
        session_token = secrets.token_urlsafe(32)
        await update_user_session(str(user['user_id']), session_token)
        
        logger.info(f"✅ User created: {email} (ID: {user['user_id']})")
        
        return JSONResponse(content={
            "success": True,
            "message": "User created successfully",
            "user": {
                "user_id": str(user['user_id']),
                "email": user['email'],
                "first_name": user['first_name'],
                "last_name": user['last_name'],
                "name": f"{user['first_name']} {user['last_name']}".strip(),
                "username": user['username'],
                "credits": user['credits']
            },
            "session_token": session_token # Corrected typo from session_2token
        })
        
    except ValueError as e:
        return JSONResponse(
            status_code=400,
            content={"error": str(e)}
        )
    except Exception as e:
        logger.error(f"Signup error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error"}
        )

@app.post("/api/auth/login")
async def login(request: Request):
    """User login endpoint."""
    try:
        body = await request.json()
        email = body.get('email')
        password = body.get('password')
        
        if not email or not password:
            return JSONResponse(
                status_code=400,
                content={"error": "Email and password are required"}
            )
        
        user = await authenticate_user(email, password)
        if not user:
            return JSONResponse(
                status_code=401,
                content={"error": "Invalid credentials"}
            )
        
        session_token = secrets.token_urlsafe(32)
        await update_user_session(str(user['user_id']), session_token)
        
        logger.info(f"✅ User logged in: {email}")
        
        return JSONResponse(content={
            "success": True,
            "message": "Login successful",
            "user": {
                "user_id": str(user['user_id']),
                "email": user['email'],
                "first_name": user['first_name'],
                "last_name": user['last_name'],
                "name": f"{user['first_name']} {user['last_name']}".strip(),
                "username": user['username'],
                "credits": user['credits']
            },
            "session_token": session_token
        })
        
    except Exception as e:
        logger.error(f"Login error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error"}
        )

@app.get("/api/auth/me")
async def get_current_user_info(current_user: dict = Depends(get_current_user)):
    """Get current user information."""
    # current_user is guaranteed to be present by Depends(get_current_user)
    return {
        "user": {
            "user_id": str(current_user['user_id']),
            "email": current_user['email'],
            "first_name": current_user['first_name'],
            "last_name": current_user['last_name'],
            "name": f"{current_user['first_name']} {current_user['last_name']}".strip(),
            "username": current_user['username'],
            "credits": current_user['credits'],
            "organization": current_user['organization']
        }
    }

@app.post("/api/auth/logout")
async def logout(current_user: dict = Depends(get_current_user)):
    """User logout endpoint."""
    # current_user is guaranteed to be present
    await update_user_session(str(current_user['user_id']), "", -1) # Clear session token
    logger.info(f"User logged out: {current_user['email']}")
    
    return {"success": True, "message": "Logged out successfully"}

# ===== AGENT MANAGEMENT ENDPOINTS (Using AgentManager) =====

@app.post("/api/agents")
async def create_agent_endpoint(request: Request, current_user: dict = Depends(get_current_user)):
    """Create a new AI agent."""
    # current_user is guaranteed to be present
    try:
        body = await request.json()
        agent_name = body.get('name', '').strip()
        agent_role = body.get('role', '').strip()
        agent_expectations = body.get('expectations', '').strip() # Using 'expectations' for description
        agent_personality = body.get('personality', {}) # Personality can be a dict

        if not agent_name or not agent_role:
            return JSONResponse(
                status_code=400,
                content={"error": "Agent name and role are required"}
            )
        
        agent = await agent_manager_instance.create_agent(
            user_id=str(current_user['user_id']),
            agent_name=agent_name,
            agent_role=agent_role,
            agent_personality=json.dumps(agent_personality), # Store as JSON string
            agent_expectations=agent_expectations
        )
        
        logger.info(f"✅ Agent created: {agent_name} for user {current_user['email']}")
        
        return JSONResponse(content={
            "success": True,
            "agent": {
                "id": str(agent['agent_id']),
                "name": agent['agent_name'],
                "role": agent['agent_role'],
                "personality": json.loads(agent['agent_personality'] or '{}'),
                "expectations": agent['agent_expectations'],
                "created": agent['created_at'].isoformat(),
                "updated": agent['updated_at'].isoformat()
            },
            "message": "Agent created successfully"
        })
        
    except Exception as e:
        logger.error(f"Create agent error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/api/agents")
async def list_agents(current_user: dict = Depends(get_current_user)):
    """List all agents for the current user."""
    # current_user is guaranteed to be present
    try:
        # AgentManager handles RLS, so no explicit ownership check needed here
        agents = await agent_manager_instance.get_user_agents(str(current_user['user_id']))
        
        formatted_agents = []
        for agent in agents:
            formatted_agents.append({
                "id": str(agent['agent_id']),
                "name": agent['agent_name'],
                "role": agent['agent_role'],
                "personality": json.loads(agent['agent_personality'] or '{}'),
                "expectations": agent['agent_expectations'],
                "created": agent['created_at'].isoformat(),
                "updated": agent['updated_at'].isoformat()
            })
        
        return {
            "agents": formatted_agents,
            "total": len(formatted_agents)
        }
        
    except Exception as e:
        logger.error(f"List agents error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.get("/api/agents/{agent_id}")
async def get_agent(agent_id: str, current_user: dict = Depends(get_current_user)):
    """Get a specific agent."""
    # current_user is guaranteed to be present
    try:
        # AgentManager handles RLS, so it will only return if owned by user or if user is admin
        agent = await agent_manager_instance.get_agent_details(agent_id, str(current_user['user_id']))
        if not agent:
            raise HTTPException(status_code=404, detail="Agent not found or access denied")
        
        return {
            "id": str(agent['agent_id']),
            "name": agent['agent_name'],
            "role": agent['agent_role'],
            "personality": json.loads(agent['agent_personality'] or '{}'),
            "expectations": agent['agent_expectations'],
            "created": agent['created_at'].isoformat(),
            "updated": agent['updated_at'].isoformat()
        }
        
    except HTTPException: # Re-raise HTTPExceptions directly
        raise
    except Exception as e:
        logger.error(f"Get agent error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

@app.delete("/api/agents/{agent_id}")
async def delete_agent_endpoint(agent_id: str, current_user: dict = Depends(get_current_user)):
    """Delete an agent."""
    # current_user is guaranteed to be present
    try:
        # AgentManager handles RLS, so it will only delete if owned by user or if user is admin
        success = await agent_manager_instance.delete_agent(agent_id, str(current_user['user_id']))
        if success:
            logger.info(f"✅ Agent deleted: {agent_id} for user {current_user['email']}")
            return {"success": True, "message": "Agent deleted successfully"}
        else:
            # If not found or not owned, delete_agent returns False due to RLS
            raise HTTPException(status_code=404, detail="Agent not found or access denied")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Delete agent error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

# ===== CREDIT MANAGEMENT ENDPOINTS =====

@app.get("/api/credits")
async def get_credits(current_user: dict = Depends(get_current_user)):
    """Get user's current credit balance."""
    # current_user is guaranteed to be present
    return {
        "credits": current_user['credits'],
        "user_id": str(current_user['user_id'])
    }

@app.get("/api/credits/history")
async def get_credits_history(current_user: dict = Depends(get_current_user)):
    """Get user's credit transaction history."""
    # current_user is guaranteed to be present
    try:
        history = await get_credit_history(str(current_user['user_id']))
        
        formatted_history = []
        for entry in history:
            formatted_history.append({
                "id": str(entry['id']),
                "change": entry['change'],
                "reason": entry['reason'],
                "service_used": entry['service_used'],
                "timestamp": entry['created_at'].isoformat()
            })
        
        return {
            "history": formatted_history,
            "total": len(formatted_history)
        }
        
    except Exception as e:
        logger.error(f"Credit history error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": str(e)}
        )

# ===== MCP_LLM AND AUTOMATION ENDPOINTS =====

@app.post("/api/ai/chat/{agent_id}")
async def ai_chat_with_agent(
    agent_id: str,
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Endpoint for interacting with a specific AI agent (MCP_LLM).
    Handles conversational turns and workflow generation.
    """
    # current_user is guaranteed to be present
    try:
        body = await request.json()
        user_message = body.get('message', '').strip()
        
        if not user_message:
            raise HTTPException(status_code=400, detail="Message is required")

        # Ensure the agent exists and belongs to the user
        agent_details = await agent_manager_instance.get_agent_details(agent_id, str(current_user['user_id']))
        if not agent_details:
            raise HTTPException(status_code=404, detail="Agent not found or access denied.")

        logger.info(f"AI Chat: User {current_user['email']} talking to Agent {agent_details['agent_name']} (ID: {agent_id})")
        
        # Process message with Custom MCP_LLM_Orchestrator
        if custom_mcp_orchestrator is None:
            raise HTTPException(status_code=503, detail="AI Orchestrator not initialized.")

        response = await custom_mcp_orchestrator.process_with_agent(
            agent_id=agent_id,
            user_input=user_message
        )
        
        # Handle different response statuses from the orchestrator
        if response["status"] == "review_needed":
            return JSONResponse(content={
                "done": False, # Still needs user confirmation
                "success": True,
                "message": response["message"], # Human-readable summary
                "workflow_json": response["workflow_json"], # The full workflow JSON to be confirmed
                "action_required": "confirm_workflow"
            })
        elif response["status"] == "info_needed":
            return JSONResponse(content={
                "done": False, # Still needs more info
                "success": True,
                "message": response["message"], # Clarifying question
                "action_required": "provide_info"
            })
        elif response["status"] == "conversational":
            return JSONResponse(content={
                "done": True, # Conversation turn complete
                "success": True,
                "message": response["message"], # General chat response
                "action_required": "none"
            })
        elif response["status"] == "error":
            raise HTTPException(status_code=500, detail=response["message"])
        
        # This case should ideally not be reached if all statuses are handled
        return JSONResponse(content={
            "done": False,
            "success": False,
            "message": "Unexpected response from AI orchestrator.",
            "action_required": "error"
        }, status_code=500)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"AI Chat endpoint error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error during AI interaction", "message": str(e)}
        )

@app.post("/api/chat/mcpai")
async def chat_with_default_mcp_assistant(
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Endpoint for interacting with the default 'Sam - Personal Assistant' AI agent.
    This endpoint automatically finds or creates the default agent for the user.
    """
    # current_user is guaranteed to be present
    try:
        body = await request.json()
        user_message = body.get('message', '').strip()
        
        if not user_message:
            raise HTTPException(status_code=400, detail="Message is required")

        # Get or create the default 'Sam' agent for the current user
        default_agent = await _get_or_create_default_agent(str(current_user['user_id']))
        default_agent_id = str(default_agent['agent_id'])

        logger.info(f"MCP AI Chat: User {current_user['email']} talking to default agent '{default_agent['agent_name']}' (ID: {default_agent_id})")
        
        # Process message with MCP_LLM_Orchestrator
        if custom_mcp_orchestrator is None:
            raise HTTPException(status_code=503, detail="AI Orchestrator not initialized.")

        # Process message with Custom MCP_LLM_Orchestrator
        logger.debug(f"🎯 DEBUG: Processing user message with Custom MCP: {user_message}")
        response = await custom_mcp_orchestrator.process_with_agent(
            agent_id=default_agent_id,
            user_input=user_message
        )
        
        # Debug log the response
        logger.debug(f"🎯 DEBUG: MCP Response: {json.dumps(response, indent=2)}")
        
        # Handle null response
        if response is None:
            logger.warning("🎯 DEBUG: MCP returned None response, providing fallback")
            return JSONResponse(content={
                "success": False,
                "response": "I'm sorry, I couldn't process that request. Please try again.",
                "agentId": default_agent_id,
                "timestamp": datetime.now().isoformat(),
                "fallback": True
            })
        
        # Handle different response statuses from the orchestrator
        if response["status"] == "review_needed":
            return JSONResponse(content={
                "done": False,
                "success": True,
                "message": response["message"],
                "workflow_json": response["workflow_json"],
                "action_required": "confirm_workflow"
            })
        elif response["status"] == "ai_service_selection":
            return JSONResponse(content={
                "done": False,
                "success": True,
                "status": "ai_service_selection",
                "message": response["message"],
                "ai_service_options": response["ai_service_options"],
                "original_request": response["original_request"],
                "estimated_credits": response["estimated_credits"],
                "action_required": "select_ai_service"
            })
        elif response["status"] == "info_needed":
            return JSONResponse(content={
                "done": False,
                "success": True,
                "message": response["message"],
                "action_required": "provide_info"
            })
        elif response["status"] == "workflow_preview":
            return JSONResponse(content={
                "done": False,
                "success": True,
                "status": "workflow_preview",
                "message": response["message"],
                "workflow_preview": response["workflow_preview"],  # THIS WAS MISSING!
                "workflow_json": response["workflow_json"],
                "workflow_id": response["workflow_id"],
                "ai_service_used": response["ai_service_used"],
                "estimated_credits": response["estimated_credits"],
                "preview_details": response["preview_details"],
                "action_required": "confirm_workflow"
            })
        elif response["status"] == "conversational":
            return JSONResponse(content={
                "done": True,
                "success": True,
                "message": response["message"],
                "action_required": "none"
            })
        elif response["status"] == "completed":
            return JSONResponse(content={
                "done": True,
                "success": True,
                "message": response["message"],
                "action_required": "none"
            })
        elif response["status"] == "error":
            raise HTTPException(status_code=500, detail=response["message"])
        elif response["status"] == "success":
            # Handle simple success responses - check if it needs AI service selection
            response_message = response.get("response", response.get("message", ""))
            
            # If it just says it will send an email, it means it needs AI service selection
            if "send an email" in response_message and "I'll" in response_message:
                return JSONResponse(content={
                    "done": False,
                    "success": True,
                    "status": "ai_service_selection",
                    "message": "I can help you generate and send that email! Please choose your preferred AI service:",
                    "ai_service_options": [
                        {
                            "id": "inhouse",
                            "name": "In-House AI",
                            "description": "Our custom MCP LLM - Lower cost, optimized for business automation",
                            "credits": 2,
                            "features": ["Fast response", "Business-focused", "Cost-effective"]
                        },
                        {
                            "id": "openai",
                            "name": "OpenAI GPT",
                            "description": "GPT-4 powered AI - High quality, versatile content generation",
                            "credits": 5,
                            "features": ["Premium quality", "Advanced reasoning", "Creative content"]
                        },
                        {
                            "id": "claude",
                            "name": "Anthropic Claude",
                            "description": "Claude AI - Excellent for analysis and detailed responses",
                            "credits": 5,
                            "features": ["Analytical", "Detailed responses", "Code-friendly"]
                        }
                    ],
                    "original_request": user_message,
                    "intent_detected": "ai_content_email",
                    "confidence": 0.95,
                    "estimated_credits": "2-5 depending on service",
                    "action_required": "select_ai_service"
                })
            else:
                # Regular conversational response
                return JSONResponse(content={
                    "done": True,
                    "success": True,
                    "message": response_message,
                    "action_required": "none"
                })
        
        return JSONResponse(content={
            "done": False,
            "success": False,
            "message": "Unexpected response from AI orchestrator.",
            "action_required": "error"
        }, status_code=500)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Default MCP AI Chat endpoint error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error during default AI interaction", "message": str(e)}
        )


@app.post("/api/automations/execute")
async def execute_automation_workflow(
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Endpoint to execute a confirmed automation workflow.
    This is called after the user confirms the workflow generated by the AI.
    """
    # current_user is guaranteed to be present
    try:
        body = await request.json()
        workflow_json = body.get('workflow_json')
        
        if not workflow_json:
            raise HTTPException(status_code=400, detail="Workflow JSON is required for execution.")
        
        logger.info(f"Executing confirmed workflow for user {current_user['email']}")
        
        if automation_engine is None:
            raise HTTPException(status_code=503, detail="Automation Engine not initialized.")

        # Pass the workflow JSON to the AutomationEngine for execution
        execution_result = await automation_engine.execute_workflow(workflow_json, str(current_user['user_id']))
        
        if execution_result.get("status") == "success":
            # Deduct credits after successful execution (conceptual)
            # await deduct_credits(str(current_user['user_id']), amount=1, reason="workflow_execution", service_used="automation_engine")
            logger.info(f"✅ Workflow executed successfully for user {current_user['email']}.")
            return JSONResponse(content={
                "success": True,
                "message": "Workflow executed successfully!",
                "execution_details": execution_result
            })
        else:
            logger.error(f"❌ Workflow execution failed for user {current_user['email']}: {execution_result.get('error')}")
            raise HTTPException(status_code=500, detail=f"Workflow execution failed: {execution_result.get('error')}")

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Execute workflow endpoint error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error during workflow execution", "message": str(e)}
        )

# Removed old simplified /chat and /execute endpoints
# Removed old generate_automation_workflow and send_email_directly functions
# Removed include_personalized_ai_routes if it was just a placeholder
# for now, assuming api.chat and api.personalized_ai are not used for these new endpoints.

@app.post("/agents/{agent_id}/chat")
async def chat_with_agent(
    agent_id: str,
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Chat endpoint for agents to handle natural language requests
    Includes email automation and other AI-powered workflows
    """
    try:
        body = await request.json()
        message = body.get('message', '').lower().strip()
        
        logger.info(f"Agent {agent_id} chat request from user {current_user['email']}: {message}")
        
        # Check if this is an email automation request
        if any(keyword in message for keyword in [
            'generate good morning content',
            'send email',
            'morning email',
            'good morning email',
            'send good morning'
        ]):
            # Extract email address from message if provided
            import re
            email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
            emails = re.findall(email_pattern, message)
            
            if emails:
                target_email = emails[0]
                logger.info(f"Email automation request for: {target_email}")
                
                # Create morning email workflow
                from datetime import datetime
                current_date = datetime.now().strftime("%B %d, %Y")
                
                workflow = {
                    "workflow_id": f"morning-email-{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    "name": "AI Generated Morning Email",
                    "description": f"Send AI-generated morning content to {target_email}",
                    "user_id": str(current_user['user_id']),
                    "trigger": {
                        "type": "manual",
                        "name": "AI Chat Trigger",
                        "description": "Triggered by AI assistant chat"
                    },
                    "actions": [
                        {
                            "action_id": "ai-morning-email-001",
                            "node": "emailSend",
                            "name": "Send AI Morning Email",
                            "parameters": {
                                "toEmail": target_email,
                                "subject": f"🌅 Good Morning! AI-Generated Positivity - {current_date}",
                                "text": f"""Good morning, wonderful soul! ☀️

"Today is a blank canvas waiting for your masterpiece. Paint it with joy, courage, and endless possibilities!" ✨

✨ YOUR AI-GENERATED DAILY AFFIRMATIONS ✨
🌟 I am capable of achieving incredible things today
💪 Every challenge I face makes me stronger and wiser
😊 I choose to see opportunities in every situation
🚀 My potential is limitless and my dreams are valid
💖 I am grateful for this fresh start and new day

🌈 Remember, you have the power to make today amazing! Today is {current_date}, and it's YOUR day to shine.

The universe has aligned perfectly to bring you this moment. Trust in your abilities, embrace your uniqueness, and step forward with confidence! ✨

Take a deep breath, smile your beautiful smile, and let your light illuminate the world around you. You've absolutely got this! 💪

Sending you positive energy and warm vibes to make your day extraordinary! 🤗

May your day be filled with unexpected joys, meaningful connections, and beautiful moments! 🌺

With AI-powered love and positivity,
EGR201 - Your Personal AI Assistant 🤖💖

---
📧 Generated by EGR201 AI Assistant | {current_date}
🌅 Powered by Advanced AI Content Generation"""
                            }
                        }
                    ],
                    "metadata": {
                        "created_by": "EGR201 AI Assistant",
                        "created_date": datetime.now().isoformat(),
                        "purpose": "AI-generated morning motivation",
                        "recipient": target_email,
                        "execution_mode": "immediate",
                        "ai_generated": True
                    }
                }
                
                # Execute the workflow
                if automation_engine is None:
                    return JSONResponse(content={
                        "success": False,
                        "message": "I understand you want to send a morning email, but the automation engine is not available right now. Please try again later.",
                        "type": "error"
                    })
                
                try:
                    # Wrap workflow in the expected structure
                    workflow_payload = {"workflow": workflow}
                    execution_result = await automation_engine.execute_workflow(workflow_payload, str(current_user['user_id']))
                    
                    if execution_result.get("status") == "success":
                        return JSONResponse(content={
                            "success": True,
                            "message": f"✅ Perfect! I've generated beautiful morning content using AI and sent it to {target_email}. The email includes personalized affirmations, motivational quotes, and positive energy to start their day right! 🌅✨",
                            "type": "success",
                            "automation_result": execution_result
                        })
                    else:
                        return JSONResponse(content={
                            "success": False,
                            "message": f"I generated the morning content, but encountered an issue sending the email to {target_email}. The automation system reported: {execution_result.get('error', 'Unknown error')}",
                            "type": "error",
                            "automation_result": execution_result
                        })
                        
                except Exception as e:
                    logger.error(f"Email automation execution failed: {e}")
                    return JSONResponse(content={
                        "success": False,
                        "message": f"I understand you want to send a morning email to {target_email}, but I encountered a technical issue with the automation system. Please try again or contact support if the problem persists.",
                        "type": "error"
                    })
            else:
                return JSONResponse(content={
                    "success": False,
                    "message": "I'd be happy to generate and send morning content! Please specify the email address you'd like me to send it to. For example: 'generate good morning content and send to example@email.com'",
                    "type": "request_info"
                })
        
        # Default response for other types of messages
        return JSONResponse(content={
            "success": True,
            "message": "I understand you want to work with emails. As a Personal Assistant, I can help you set up email automation workflows. What email tasks would you like me to help you with?",
            "type": "general"
        })
        
    except Exception as e:
        logger.error(f"Agent chat error: {e}")
        return JSONResponse(content={
            "success": False,
            "message": "I apologize, but I encountered an error processing your request. Please try again.",
            "type": "error"
        }, status_code=500)

@app.post("/api/workflow/generate")
async def generate_workflow_with_mcp(
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Generate workflow using Custom MCP LLM system
    Endpoint for testing MCP LLM workflow generation
    """
    try:
        body = await request.json()
        user_message = body.get('message', '').strip()
        user_id = body.get('user_id') or str(current_user['user_id'])
        agent_id = body.get('agent_id', 'sam')
        
        if not user_message:
            raise HTTPException(status_code=400, detail="Message is required")

        logger.info(f"Workflow Generation: User {current_user['email']} requesting workflow: {user_message}")
        
        # Get Custom MCP orchestrator
        from mcp.simple_mcp_llm import get_mcp_orchestrator
        custom_orchestrator = get_mcp_orchestrator()
        
        # Process message with Custom MCP agent
        response = await custom_orchestrator.process_with_agent(
            agent_id=agent_id,
            user_input=user_message
        )
        
        if response.get("response_type") == "workflow" and response.get("workflow_json"):
            # Extract workflow info for test compatibility
            workflow_json = response["workflow_json"]
            
            # Convert to test-compatible format
            workflow_steps = []
            for node in workflow_json.get("nodes", []):
                step = {
                    "action_type": node.get("type", "unknown"),
                    "parameters": node.get("parameters", {})
                }
                
                # Add content for email generation detection
                if node.get("type") == "email_send":
                    step["action_type"] = "email_generation"
                    step["parameters"]["content"] = node.get("parameters", {}).get("body", "Custom MCP generated content")
                
                workflow_steps.append(step)
            
            test_workflow = {
                "id": workflow_json.get("workflow_id"),
                "name": workflow_json.get("workflow_name", "MCP Generated Workflow"),
                "steps": workflow_steps,
                "mcp_generated": True
            }
            
            return JSONResponse({
                "success": True,
                "message": "Workflow generated using Custom MCP LLM",
                "workflow": test_workflow,
                "original_response": response
            })
        
        else:
            # Not a workflow request
            return JSONResponse({
                "success": False,
                "message": "Request did not generate a workflow",
                "response": response.get("response", "")
            })
        
    except Exception as e:
        logger.error(f"Workflow generation error: {e}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.post("/api/workflow/confirm")
async def confirm_workflow(
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """
    Confirm and execute a workflow that's in preview state
    """
    try:
        body = await request.json()
        workflow_json = body.get('workflow_json')
        
        if not workflow_json:
            raise HTTPException(status_code=400, detail="Workflow JSON is required")
        
        logger.info(f"Executing workflow for user {current_user['email']}")
        
        # DEBUG: Log the received workflow_json structure
        logger.info(f"🔍 BACKEND DEBUG: Received workflow_json: {json.dumps(workflow_json, indent=2)}")
        logger.info(f"🔍 BACKEND DEBUG: Workflow type: {workflow_json.get('type')}")
        logger.info(f"🔍 BACKEND DEBUG: Workflow keys: {list(workflow_json.keys())}")
        
        # Execute the workflow using real automation
        logger.info("🚀 Executing real workflow automation...")
        
        try:
            # Check if this is an email workflow
            workflow_type = workflow_json.get("type")
            logger.info(f"🔍 BACKEND DEBUG: Checking workflow type: '{workflow_type}' == 'email_automation'? {workflow_type == 'email_automation'}")
            
            if workflow_type == "email_automation":
                recipient = workflow_json.get("recipient", "test@example.com")
                content_type = workflow_json.get("content_type", "marketing email")
                ai_service = workflow_json.get("ai_service", "none")
                needs_ai_generation = workflow_json.get("needs_ai_generation", False)
                
                logger.info(f"📧 Sending {content_type} to {recipient} using AI service: {ai_service}")
                
                # Execute MCP LLM workflow properly using automation engine
                if needs_ai_generation and ai_service != "none":
                    logger.info(f"🤖 Using MCP LLM system for AI content generation (service: {ai_service})")
                    
                    # Get the workflow data - prefer workflow.actions over top-level actions
                    workflow_data = workflow_json.get("workflow", {})
                    actions = workflow_data.get("actions", workflow_json.get("actions", []))
                    logger.info(f"🎯 BACKEND DEBUG: Found {len(actions)} actions in workflow")
                    
                    # Execute workflow through automation engine instead of manual processing
                    logger.info("🔧 Executing workflow through automation engine...")
                    
                    try:
                        # Import and use the automation engine
                        from mcp.simple_automation_engine import AutomationEngine
                        automation_engine = AutomationEngine()
                        
                        # Prepare workflow for automation engine
                        workflow_for_engine = {
                            "name": f"MCP_Email_Workflow_{ai_service}",
                            "type": "email_automation",
                            "actions": []
                        }
                        
                        # Convert MCP workflow actions to automation engine format
                        for action in actions:
                            action_type = action.get("node") or action.get("action_type", "unknown")
                            params = action.get("parameters", {})
                            
                            if action_type == "mcpLLM":
                                # Add AI content generation action
                                workflow_for_engine["actions"].append({
                                    "type": "content_generation",
                                    "parameters": {
                                        "user_input": params.get("user_input", f"Create {content_type}"),
                                        "content_type": content_type,
                                        "ai_service": ai_service,
                                        "user_id": current_user.get('user_id'),
                                        "agent_id": workflow_json.get("agent_id", "unknown")
                                    }
                                })
                            elif action_type == "emailSend":
                                # Add email sending action
                                workflow_for_engine["actions"].append({
                                    "type": "email",
                                    "parameters": {
                                        "to": params.get("toEmail", recipient),
                                        "subject": params.get("subject", f"🔦 AI-Generated {content_type.title()}"),
                                        "body": params.get("content") or params.get("text", "{ai_generated_content}"),
                                        "from_user": current_user.get('email'),
                                        "smtp_config": {
                                            "host": os.getenv('SMTP_HOST', 'mail.privateemail.com'),
                                            "port": int(os.getenv('SMTP_PORT', 587)),
                                            "user": os.getenv('SMTP_USER', 'automation-engine@dxtr-labs.com'),
                                            "password": os.getenv('SMTP_PASSWORD')
                                        }
                                    }
                                })
                        
                        logger.info(f"🚀 Executing workflow with {len(workflow_for_engine['actions'])} actions through automation engine")
                        
                        # Execute the workflow through automation engine
                        execution_result = await automation_engine.execute_workflow(workflow_for_engine)
                        
                        logger.info(f"✅ Automation engine execution completed: {execution_result.get('status')}")
                        
                        # Check if execution was successful
                                        }if execution_result.get('status') in ['completed', 'partial_success']:
                                    }
                                })
                                "message": execution_result.get('message'),
                        logger.info(f"🚀 Executing workflow with {len(workflow_for_engine['actions'])} actions through automation engine")
                            }
                        # Execute the workflow through automation engine
                        execution_result = await automation_engine.execute_workflow(workflow_for_engine)
                        alse,
                        logger.info(f"✅ Automation engine execution completed: {execution_result.get('status')}")on_result.get('message', 'Automation engine execution failed'),
                        
                        # Check if execution was successful
                        if execution_result.get('status') in ['completed', 'partial_success']:
                            email_result = {ception as e:
                                "success": True,omation engine execution failed: {str(e)}")
                                "message": execution_result.get('message'),
                                "execution_details": execution_result
                            }e)}"
                        else:
                            email_result = {
                                "success": False,
                                "error": execution_result.get('message', 'Automation engine execution failed'),
                                "execution_details": execution_resultding simple email without AI generation")
                            }
                            
                    except Exception as e: Generate premium email content
                        logger.error(f"❌ Automation engine execution failed: {str(e)}")        html_content, text_content = generate_premium_template(
                        email_result = {       recipient_name="Valued Customer",
                            "success": False,
                            "error": f"Automation engine error: {str(e)}"
                        }    
                l
                else:ly(
                    # Simple email without AI generation
                    logger.info(f"📧 Sending simple email without AI generation")tions for Your Business - DXTR Labs",
                    
                    if EMAIL_AVAILABLE:   html_body=html_content
                        # Generate premium email content)
                        html_content, text_content = generate_premium_template(
                            recipient_name="Valued Customer",ilable
                            sender_name="Sam Rodriguez"
                        )
                        simulated (email_sender module not available)"
                        # Send the email
                        email_result = send_email_directly(
                            to_email=recipient,result.get("success"):
                            subject="🚀 Revolutionary AI Solutions for Your Business - DXTR Labs",
                            body=text_content,ss",
                            html_body=html_contentkflow_{int(time.time())}",
                        )
                    else:details": f"Real email automation completed: {email_result.get('message')}",
                        # Simulate email sending if not available        "email_sent": True,
                        email_result = {
                            "success": True,evolutionary AI Solutions for Your Business - DXTR Labs"
                            "message": "Email simulated (email_sender module not available)"
                        }ent}")
                
                if email_result.get("success"):
                    execution_result = {
                        "status": "success",ow_{int(time.time())}",
                        "workflow_id": f"workflow_{int(time.time())}",
                        "message": f"✅ Marketing email successfully sent to {recipient}!",   "details": "Email automation failed",
                        "details": f"Real email automation completed: {email_result.get('message')}",
                        "email_sent": True,
                        "recipient": recipient,il failed: {email_result.get('error')}")
                        "subject": "🚀 Revolutionary AI Solutions for Your Business - DXTR Labs"
                    }
                    logger.info(f"✅ Email sent successfully to {recipient}")
                else:
                    execution_result = {ow_{int(time.time())}",
                        "status": "error",message": "Workflow submitted for execution",
                        "workflow_id": f"workflow_{int(time.time())}",
                        "message": f"❌ Failed to send email: {email_result.get('error')}",
                        "details": "Email automation failed",
                        "email_sent": False
                    }ecution failed: {str(e)}")
                    logger.error(f"❌ Email failed: {email_result.get('error')}")
            else:
                # For non-email workflows, still simulate
                execution_result = {message": f"Workflow execution failed: {str(e)}",
                    "status": "success","details": "Automation engine error"
                    "workflow_id": f"workflow_{int(time.time())}",
                    "message": "Workflow submitted for execution",
                    "details": "Non-email workflow simulated successfully""status") == "success":
                }ow executed successfully for user {current_user['email']}")
                
        except Exception as e:
            logger.error(f"❌ Workflow execution failed: {str(e)}")sfully!",
            execution_result = {   "execution_details": execution_result
                "status": "error",    })
                "workflow_id": f"workflow_{int(time.time())}",
                "message": f"Workflow execution failed: {str(e)}",
                "details": "Automation engine error"de=500, detail=f"Workflow execution failed: {execution_result.get('error')}")
            }
        
        if execution_result.get("status") == "success":
            logger.info(f"✅ Workflow executed successfully for user {current_user['email']}")eption as e:
            return JSONResponse(content={r.error(f"Workflow confirmation endpoint error: {e}", exc_info=True)
                "success": True,
                "message": "Workflow executed successfully!",
                "execution_details": execution_resultcontent={"error": "Internal server error during workflow confirmation", "message": str(e)}
            })
        else:
            logger.error(f"❌ Workflow execution failed: {execution_result.get('error')}")orkflow_id}/preview")
            raise HTTPException(status_code=500, detail=f"Workflow execution failed: {execution_result.get('error')}")
            
    except HTTPException:ends(get_current_user)
        raise
    except Exception as e:
        logger.error(f"Workflow confirmation endpoint error: {e}", exc_info=True)    Get workflow preview details for user review
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error during workflow confirmation", "message": str(e)}mode, return a basic preview
        )
          "workflow_id": workflow_id,
@app.get("/api/workflow/{workflow_id}/preview")     "message": "Workflow preview not available in simple mode",
async def get_workflow_preview(
    workflow_id: str, })
    current_user: dict = Depends(get_current_user)    
):
    """
    Get workflow preview details for user review
    """True)
    try:
        # For simple mode, return a basic preview  status_code=500,
        return JSONResponse(content={content={"error": "Internal server error during workflow preview", "message": str(e)}
            "workflow_id": workflow_id,
            "message": "Workflow preview not available in simple mode",
            "status": "simple_mode"TS (FOR TESTING) =====
        })
            irect")
    except HTTPException:quest: Request):
        raise
    except Exception as e:t MCP chat endpoint for testing without authentication
        logger.error(f"Workflow preview endpoint error: {e}", exc_info=True)    """
        return JSONResponse(
            status_code=500,        body = await request.json()
            content={"error": "Internal server error during workflow preview", "message": str(e)}', 'test_user')
        )t_agent')
 user_message = body.get('user_message', '')
# ===== DIRECT MCP ENDPOINTS (FOR TESTING) =====
 logger.info(f"🎯 DIRECT MCP: Processing message from {user_id}: {user_message}")
@app.post("/api/chat/mcpai/direct")
async def chat_direct_mcp(request: Request):om MCP_LLM_Orchestrator
    """.process_with_agent(
    Direct MCP chat endpoint for testing without authentication
    """
    try:)
        body = await request.json()
        user_id = body.get('user_id', 'test_user')logger.info(f"🎯 DIRECT MCP: Result status: {mcp_result.get('status')}")
        agent_id = body.get('agent_id', 'test_agent')
        user_message = body.get('user_message', '')
        
        logger.info(f"🎯 DIRECT MCP: Processing message from {user_id}: {user_message}")
        ogger.error(f"Direct MCP chat error: {e}")
        # Process message with Custom MCP_LLM_Orchestratorreturn JSONResponse(content={
        mcp_result = await custom_mcp_orchestrator.process_with_agent(
            agent_id=agent_id,    "message": "I apologize, but I encountered an error processing your request. Please try again.",
            user_input=user_message
        )}, status_code=500)
        
        logger.info(f"🎯 DIRECT MCP: Result status: {mcp_result.get('status')}")
        uest: Request):
        return JSONResponse(content=mcp_result)
        
    except Exception as e:
        logger.error(f"Direct MCP chat error: {e}")
        return JSONResponse(content={        body = await request.json()
            "success": False,w_json')
            "message": "I apologize, but I encountered an error processing your request. Please try again.",
        if not workflow_json:
            raise HTTPException(status_code=400, detail="Workflow JSON is required")
        
        logger.info(f"🎯 DIRECT WORKFLOW: Executing workflow...")
        logger.info(f"🔍 Workflow JSON: {json.dumps(workflow_json, indent=2)}")
        
        # Execute the workflow using real automation
        logger.info("🚀 Executing real workflow automation...")
        
        try:
            # Check if this is an email workflow
            workflow_type = workflow_json.get("type")
            logger.info(f"🔍 Workflow type: '{workflow_type}'")
            
            if workflow_type == "email_automation":
                recipient = workflow_json.get("recipient", "test@example.com")
                content_type = workflow_json.get("content_type", "marketing email")
                ai_service = workflow_json.get("ai_service", "none")
                needs_ai_generation = workflow_json.get("needs_ai_generation", False)
                
                logger.info(f"📧 Email workflow: {content_type} to {recipient} using {ai_service}")
                
                # Execute MCP LLM workflow properly
                if needs_ai_generation and ai_service != "none":
                    logger.info(f"🤖 Using MCP LLM system for AI content generation")
                    
                    # Get the workflow actions
                    actions = workflow_json.get("actions", [])
                    logger.info(f"🎯 Found {len(actions)} actions in workflow")
                    
                    ai_content = None
                    email_params = None
                    
                    # Process each action in sequence
                    for i, action in enumerate(actions):
                        action_type = action.get("node", "unknown")
                        logger.info(f"🔄 Processing action {i+1}: {action_type}")
                        
                        if action_type == "mcpLLM":
                            # Generate AI content using MCP LLM
                            user_input = action.get("parameters", {}).get("user_input", f"Create {content_type}")
                            logger.info(f"🤖 Generating AI content for: {user_input}")
                            
                            # Use the Custom MCP LLM to generate content
                            # For now, generate a simple response
                            ai_content = f"AI-generated {content_type} content for: {user_input}"
                            logger.info(f"✅ Generated {len(ai_content)} characters of AI content")
                            
                        elif action_type == "emailSend":
                            # Extract email parameters
                            params = action.get("parameters", {})
                            email_params = {
                                "to_email": params.get("toEmail", recipient),
                                "subject": params.get("subject", f"🔦 AI-Generated {content_type.title()}"),
                                "content": params.get("content", "{ai_generated_content}")
                            }
                            logger.info(f"📧 Email parameters prepared for {email_params['to_email']}")
                    
                    # Send the email with AI-generated content
                    if ai_content and email_params:
                        final_content = email_params["content"].replace("{ai_generated_content}", ai_content)
                        
                        logger.info(f"📧 Sending email with {len(final_content)} chars of content")
                        logger.info(f"📧 Preview: {final_content[:200]}...")
                        
                        email_result = send_email_directly(
                            to_email=email_params["to_email"],
                            subject=email_params["subject"],
                            body=final_content
                        )
                        logger.info(f"📧 Email result: {email_result}")
                    else:
                        logger.error("❌ Missing AI content or email parameters")
                        email_result = {"success": False, "error": "Missing AI content or email parameters"}
                
                if email_result.get("success"):
                    execution_result = {
                        "status": "success",
                        "workflow_id": f"workflow_{int(time.time())}",
                        "message": f"✅ AI-generated email successfully sent to {recipient}!",
                        "details": f"MCP LLM workflow completed: {email_result.get('message')}",
                        "email_sent": True,
                        "recipient": recipient,
                        "ai_content_length": len(ai_content) if ai_content else 0
                    }
                    logger.info(f"✅ Email sent successfully to {recipient}")
                else:
                    execution_result = {
                        "status": "error",
                        "workflow_id": f"workflow_{int(time.time())}",
                        "message": f"❌ Failed to send email: {email_result.get('error')}",
                        "details": "Email automation failed",
                        "email_sent": False
                    }
                    logger.error(f"❌ Email failed: {email_result.get('error')}")
            else:
                execution_result = {
                    "status": "error",
                    "workflow_id": f"workflow_{int(time.time())}",
                    "message": "Unknown workflow type",
                    "details": f"Workflow type '{workflow_type}' not supported"
                }
                
        except Exception as e:
            logger.error(f"❌ Workflow execution failed: {str(e)}")
            execution_result = {
                "status": "error",
                "workflow_id": f"workflow_{int(time.time())}",
                "message": f"Workflow execution failed: {str(e)}",
                "details": "Automation engine error"
            }
        
        if execution_result.get("status") == "success":
            logger.info(f"✅ Direct workflow executed successfully")
            return JSONResponse(content={
                "success": True,
                "message": "Workflow executed successfully!",
                "execution_details": execution_result
            })
        else:
            logger.error(f"❌ Direct workflow execution failed: {execution_result.get('message')}")
            return JSONResponse(content={
                "success": False,
                "message": execution_result.get('message'),
                "execution_details": execution_result
            }, status_code=500)
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Direct workflow confirmation error: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": "Internal server error during workflow confirmation", "message": str(e)}
        )

if __name__ == "__main__":
    import uvicorn
    
    logger.info("🚀 Starting AutoFlow AI FastAPI Backend...")
    logger.info("📡 Server will be available at: http://127.0.0.1:8002")
    logger.info("📖 API Documentation: http://127.0.0.1:8002/docs")
    
    uvicorn.run(
        "main:app",
        host="127.0.0.1",
        port=8002,
        reload=True,
        log_level="info"
    )
